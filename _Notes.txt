==================================================================================
Notes.txt
==================================================================================

------------------------------------
Support for long-running calculations

DESIRED:
--UI responsive always
--UI shows non-invasive spinner while any caclulation is in progress
--Sequencer does not initiate a step until prior calc is done
--Interim results (e.g., partial basins) get displayed ASAP
--Any UI control-changes during calc are combined into 1
    (User clicks "+" 10 times but only 1 reclc is done)
--anything can ask for any calc to be done anytime
--If result is no longer wanted when calc finishes, it is silently discarded

-----------------------------
DESIGN #1: ad-hoc piecemeal
advantages: less disruptive; I can see how to impl it
disadvantages: need to know in advance which things to do in the background
...which we don't, in general, but we do have a clue in particular cases.
...but there's an evolutionary path: move things onto BG threads one by one
until they're all there.

[ ] appModel state is maintained on the main dispatch thread, same as now
    this includes effects, color sources, everything

[ ] AppModel API contains a method that takes a work item & a result-callback
[ ] WorkItem<T>
    callback w/ signature (T)
    methods exec() and cancel()
[ ] AppModel1 maintains a simple queue

[ ] calc's take place using the global dispatch queue w/ "user-initiated" QoS
[ ] calc's are 100% isolated from appModel state, and are 100% side-effect free
    so, e.g., they get DUPLICATE physics & geometry
[ ] calc's are queued
[ ] calc's are cancelable (at calc-impl's discretion)
[ ] viz checks on every frame to see if any calc is in progress, skips step if so

[?] what if the thing that's taking so long is setting color data? Do we then have to do
    a 2nd copy? Or can we protect it w a mutex?

-----------------------------------
DESIGN #2 all changes in the model & color sources & sequencers occur on a background thread. There's
a sync point btw the 2 threads that gets hit every frame.

Will it be easier or harder to support 10-clicks-collapsed-to-1-mod? Stepper knows its own value;
textfield knows its own text.

I think I'll end up passing total state info back & forth, and maintaining 2 copies, one per thread.


-----------------------------------
L & F

[/] section: spacing = 4
[/] section title: system light 12.0
[/] vspace above section body: 8
[/] spacing above section: 16
[/] popup button color: default
[/] popup button border: none
[/] text field: border: "rounded edges"
[/] text field: clear button: never appears
[/] all fonts except section titles: 16
[/] text field: font size: adjust to fit: no
[/] text field: keyboard type: "decimal pad"


-----------------------------------
from https://www.raywenderlich.com/5223/beginning-opengl-es-2-0-with-glkit-part-1

By default, the GLKView only updates itself on an as-needed basis - i.e. when views are first shown, the size changes, or the like. However for game programming, you often need to redraw every frame!

We can disable this default behavior of GLKView by setting enableSetNeedsDisplay to false. Then, we can control when the redrawing occurs by calling the display method on GLKView whenever we want to update the screen.

Ideally we would like to synchronize the time we render with OpenGL to the rate at which the screen refreshes.

Luckily, Apple provides an easy way for us to do this with CADisplayLink! It’s really easy to use so let’s just dive in. First add this import to the top of AppDelegate.m:

------------------------------------

/**
m = #steps to the RIGHT of p1. max = k
n = #steps to the LEFT of p1 (= #steps to the RIGHT of p2). max = N-k
*/

==================================================================================
OptionSet
==================================================================================
Split view controller:

https://www.raywenderlich.com/173753/uisplitviewcontroller-tutorial-getting-started-2

==================================================================================
Custom view controller class

https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/ImplementingACustomControl.html

To create a subclass of UIStackView

Choose File > New > File (or press Command-N).

At the top of the dialog that appears, select iOS.

Select Cocoa Touch Class, and click Next.

In the Class field, type RatingControl.

In the “Subclass of” field, select UIStackView.

Make sure the Language option is set to Swift.

select 'make xib'

==================================================================================

Having each physical quantity compute its own bounds is OK so long as there's only
one physical quantity that is being kept fresh. Otherwise, it's inefficient.

At present, there's only one pysical quantity being kept fresh.

Q: But how would I deal w/ more than one?
A: markStale and a func to take a value as part of setting new bounds. Weird & icky.

=================================================================================
“The willSet and didSet observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called. They are not called while a class is setting its own properties, before the superclass initializer has been called.”

Excerpt From: Apple Inc. “The Swift Programming Language (Swift 4.0.3).” iBooks. https://itunes.apple.com/us/book/the-swift-programming-language-swift-4-1/id881256329?mt=11


==================================================================================

who creates the geometry & physics?
currently the app does it and passes it to the controllers
option 1 the scene should do it

Who create the scene?
Currently detailviewcontroller creates it
the app delegate should create it but it should NOT create things that expects a view.

=================================

make threading issue appear: click a stepper.
somebody gets unhappy about the part that's updating model controls

